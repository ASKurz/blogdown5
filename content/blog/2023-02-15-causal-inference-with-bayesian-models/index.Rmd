---
title: Causal inference with  Bayesian models
subtitle: 'Part 4 of the GLM and causal inference series.'
author: A. Solomon Kurz
date: '2023-02-15'
excerpt: "In this fourth post, we refit the models from the previous posts with Bayesian software, and show how to compute our primary estimates when working with posterior draws. The content will be very light on theory, and heavy on methods. So if you don't love that Bayes, you can feel free to skip this one."
tags:
  - ANCOVA
  - ANOVA
  - ATE
  - Bayesian
  - binary
  - binonial
  - CATE
  - causal inference
  - g-computation
  - GLM
  - logistic regression
  - marginal standardization
  - potential outcomes
  - R
  - RCT
  - tidyverse
  - tutorial
draft: false
layout: single
featured: no
bibliography: /Users/solomonkurz/Dropbox/blogdown5/content/blog/my_blog.bib
biblio-style: apalike
csl: /Users/solomonkurz/Dropbox/blogdown5/content/blog/apa.csl  
link-citations: yes
---

```{r, echo = F, cache = F}
# knitr::opts_chunk$set(fig.retina = 2.5)
options(width = 120)
```

```{r, echo = F}
# save(fit1, file = "fits/fit1.rda")
# save(fit2, file = "fits/fit2.rda")
# save(fit3, file = "fits/fit3.rda")
# save(fit4, file = "fits/fit4.rda")

load("fits/fit1.rda")
load("fits/fit2.rda")
load("fits/fit3.rda")
load("fits/fit4.rda")
```

In the first two posts of this series, we relied on ordinary least squares (OLS). In the third post, we expanded to maximum likelihood for a couple logistic regression models. In all cases, we approached inference from a frequentist perspective. In this post, we'll refit the models from the previous posts with the Bayesian **brms** package [@R-brms; @burknerBrmsPackageBayesian2017; @burknerAdvancedBayesianMultilevel2018], and show how to compute our primary estimates when working with posterior draws. This post will be very light on theory, and heavy on methods. So if you don't love that Bayes, you can feel free to skip this one.

## Gaussian models as a Bayesian

Let's revisit the @horan1971coverant data from the first two posts.

```{r, warning = F, message = F}
# load packages
library(tidyverse)
library(brms)
library(tidybayes)
library(marginaleffects)

# adjust the global theme
theme_set(theme_gray(base_size = 13) +
            theme(panel.grid = element_blank()))

# load the data
load(file = "data/horan1971.rda")

# wrangle a bit
horan1971 <- horan1971 %>% 
  filter(treatment %in% c("delayed", "experimental")) %>% 
  mutate(prec = pre - mean(pre),
         experimental = ifelse(treatment == "experimental", 1, 0))
```

### Gaussian models.

Instead of writing our models with OLS-style notation where we include $\epsilon_i$, we'll be switching to the Gaussian likelihoodist format. Here's what are Gaussian ANOVA-type model might look like when including our Bayesian priors:

$$
\begin{align*}
\text{post}_i & \sim \operatorname{Normal}(\mu_i, \sigma) \\
\mu_i & = \beta_0 + \beta_1 \text{experimental}_i \\
\beta_0 & \sim \operatorname{Normal}(156.5, 15) \\
\beta_1 & \sim \operatorname{Normal}(0, 15) \\
\sigma & \sim \operatorname{Exponential}(0.067).
\end{align*}
$$

The prior for $\beta_0$ is centered on 156.5 because according to the Centers for Disease Control and Prevention (CDC; see [here](https://www.cdc.gov/nchs/fastats/body-measurements.htm)), that is the average weight for 19-year-old women in the US in recent years (2015-2018). Granted, the @horan1971coverant data were from some 50 years ago, but since body weight has increased over the past few decades in the US, an average woman's weight now might be a decent first approximation for an overweight woman 50 years ago. The standard deviation of 15 in the prior is meant to reflect uncertainty in the prior, and suggest that 95% of the prior mass should be between 30 points below and above the prior mean.

The prior for $\beta_1$ is centered on 0 to weakly regularize the estimate for the experimental difference towards smaller values. However, we continue to use a fairly permissive standard deviation of 15 to allow for somewhat large treatment effects. That is, there could be a difference between the groups as large as 30 pounds either way, but smaller differences are more plausible than larger ones.

When switching to the likelihoodist framework, we speak in terms of $\sigma$, rather than $\epsilon$. Since $\sigma$ must be positive, we have used the exponential distribution. The $\lambda$ parameter in the exponential distribution is the reciprocal of the mean. Though I'm no weight or weight loss researcher, my first blind guess at a standard deviation for women's weights is somewhere around 15, which means a rate of about 0.067.

```{r}
1 / 15  # the exponential rate is the reciprocal of the mean
```

If you haven't worked with exponential priors for $\sigma$ parameters before, they're nice in that they place a lot of uncertainty around the mean. To give you a sense, here's what our $\operatorname{Exponential}(0.067)$ prior looks like in a plot.

```{r, fig.width = 5.5, fig.height = 3}
prior(exponential(0.067), class = sd) %>% 
  parse_dist() %>% 
  
  ggplot(aes(y = 0, dist = .dist, args = .args)) +
  stat_dist_halfeye(point_interval = mean_qi, .width = .95) +
  scale_x_continuous(expression(italic(p)(sigma)), breaks = c(0, 15, 50, 100)) +
  scale_y_continuous(NULL, breaks = NULL) +
  labs(title = "Exponential(0.067)",
       subtitle = "The point and horizontal line mark the mean and 95% interval.")
```

Extrapolating, we might express our Bayesian Gaussian ANCOVA-type model as

$$
\begin{align*}
\text{post}_i & \sim \operatorname{Normal}(\mu_i, \sigma) \\
\mu_i & = \beta_0 + \beta_1 \text{experimental}_i + \beta_2 \text{prec}_i\\
\beta_0 & \sim \operatorname{Normal}(156.5, 15) \\
\beta_1 & \sim \operatorname{Normal}(0, 15) \\
\beta_2 & \sim \operatorname{Normal}(0.75, 0.25) \\
\sigma & \sim \operatorname{Exponential}(0.133),
\end{align*}
$$

where the new parameter $\beta_2$ accounts for our baseline covariate, the mean-centered weights before the intervention (`prec`). For simplicity, the priors for $\beta_0$ and $\beta_1$ are the same as before.

The prior for our new parameter $\beta_2$ is more certain than the others. This is because, even as someone who does not do weight loss research, I am very confident that a variable like weight will have a strong positive correlation before and after an 8-week period. Thus, we should expect $\beta_2$ to be somewhere betwen about 0.5 and 1. Here's what the $\operatorname{Normal}(0.75, 0.25)$ prior looks like:

```{r, fig.width = 5.5, fig.height = 3}
prior(normal(0.75, 0.25), class = sd) %>% 
  parse_dist() %>% 
  
  ggplot(aes(y = 0, dist = .dist, args = .args)) +
  stat_dist_halfeye(point_interval = mean_qi, .width = .95,
                    p_limits = c(.0001, .9999)) +
  scale_y_continuous(NULL, breaks = NULL) +
  coord_cartesian(xlim = c(0, 1.5)) +
  labs(title = "Normal(0.75, 0.25)",
       subtitle = "The point and horizontal line mark the mean and 95% interval.",
       x = expression(italic(p)(beta[2])))
```

Frankly, I think you could even justify a tighter prior than this. As to $\sigma$, I'm now using an exponential distribution with a mean of 7.5, which is half the magnitude we used in the previous model. This is to account for the substantial amount of variation I expect to account for with our baseline covariate `prec`.

```{r}
1 / 7.5  # the exponential rate is the reciprocal of the mean
```

```{r, fig.width = 5, fig.height = 3, eval = F, echo = F}
prior(exponential(0.133), class = sd) %>% 
  parse_dist() %>% 
  
  ggplot(aes(y = 0, dist = .dist, args = .args)) +
  stat_dist_halfeye(point_interval = mean_qi, .width = .95) +
  scale_x_continuous(expression(italic(p)(sigma)), breaks = c(0, 7.5, 25, 50)) +
  scale_y_continuous(NULL, breaks = NULL) +
  labs(title = "Exponential(0.133)",
       subtitle = "The point and horizontal line mark the mean and 95% interval.")
```

My guess is a proper weight loss researcher could come up with better priors. But I'm comfortable using these for the sake of a blog. Here's how to fit these two models with the `brm()` function from **brms**.

```{r, eval = F}
# Bayesian Gaussian ANOVA
fit1 <- brm(
  data = horan1971,
  family = gaussian,
  post ~ 0 + Intercept + experimental,
  prior = prior(normal(156.5, 15), class = b, coef = Intercept) +
    prior(normal(0, 15), class = b, coef = experimental) +
    prior(exponential(0.067), class = sigma),
  cores = 4, seed = 4
)

# Bayesian Gaussian ANCOVA
fit2 <- brm(
  data = horan1971,
  family = gaussian,
  post ~ 0 + Intercept + experimental + prec,
  prior = prior(normal(156.5, 15), class = b, coef = Intercept) +
    prior(normal(0, 15), class = b, coef = experimental) +
    prior(normal(0.75, 0.25), class = b, coef = prec) +
    prior(exponential(0.133), class = sigma),
  cores = 4, seed = 4
)
```

In this case, the parameter summaries for these two models are pretty close to their OLS analogues from earlier posts.

```{r}
print(fit1)
print(fit2)
```

### Counterfactual interventions, no covariates, with the Gauss.

Conceptually, $\tau_\text{ATE}$ is the same for Bayesians as it is for frequentists, in that

$$\tau_\text{ATE} = \mathbb E (y_i^1 - y_i^0) = \mathbb E (y_i^1) - \mathbb E (y_i^0).$$

So all the equations we learned about in the last couple posts still apply. However, applied Bayesian inference via MCMC methods adds a new procedural complication for the $\mathbb E (y_i^1 - y_i^0)$ method. If you let $j$ stand for a given MCMC draw, we end up computing 

$$\tau_{\text{ATE}_j} = \mathbb E_j (y_{ij}^1 - y_{ij}^0), \ \text{for}\ j = 1, \dots, J,$$

which in words means we compute the familiar $\mathbb E (y_i^1 - y_i^0)$ for each of the $J$ MCMC draws. This returns a $J$-row vector for the $\tau_\text{ATE}$ distribution, which we can then summarize the same as we would any other dimension of the posterior distribution. You'll see. Anyway, the workflow in this section will follow the same basic order we used in the [second post](https://timely-flan-2986f4.netlify.app/blog/2023-02-06-causal-inference-with-potential-outcomes-bootcamp/#causal-inference).

#### Compute $\mathbb E (y_i^1) - \mathbb E (y_i^0)$ from `fit1`.

Before we go into full computation mode, we might want to streamline some of our summarizing code with a custom function. Many of the functions from the **brms** package summarize the posterior draws in terms of their mean, standard deviation, and percentile-based 95% intervals. Those are common Bayesian analogues to the frequentist point estimate, standard error, and 95% confidence intervals, respectively. Here we'll make a custom function that will compute those summary statistics for all vectors in a data frame.

```{r}
brms_summary <- function(x) {
  posterior::summarise_draws(x, "mean", "sd",  ~quantile(.x, probs = c(0.025, 0.975)))
}
```

To give credit where it's due, the internals for our `brms_summary()` function come from the **posterior** package [@R-posterior]. To give you a sense of how this works, here's how to use `brms_summary()` for the 3 model parameters from `fit1`.

```{r, warning = F}
# retrieve the MCMC draws
as_draws_df(fit1) %>% 
  # subset to our 3 focal columns
  select(b_Intercept:sigma) %>% 
  # summarize
  brms_summary()
```

Now we have `brms_summary()`, we're read to compute the ATE via the $\mathbb E (y_i^1) - \mathbb E (y_i^0)$ method. As our first attempt, we'll use a `fitted()`-based approach.

```{r}
nd <- tibble(experimental = 0:1)

fitted(fit1,
       newdata = nd,
       summary = F) %>% 
  data.frame() %>% 
  set_names(pull(nd, experimental)) %>% 
  mutate(ate = `1` - `0`) %>% 
  brms_summary()
```

The first two rows are the posterior summaries for $\mathbb E (y_i^0)$ and $\mathbb E (y_i^1)$, and the final row is the summary for our focal estimate $\tau_\text{ATE}$.

Many of the functions from the **marginaleffects** package will work with **brms** models, too. For example, here's the same kind of `predictions()`-based workflow we used in the last two blog posts.

```{r}
# predicted means
predictions(fit1, newdata = nd, by = "experimental")
# ATE
predictions(fit1, newdata = nd, by = "experimental", hypothesis = "revpairwise")
```

In Arel-Bundock's [-@arelBundock2023BayesianAnalysis] vignette, *Bayesian analysis with brms*, we learn the **marginaleffects** package defaults to summarizing Bayesian posteriors by their medians. I generally prefer the **brms** convention of summarizing them by their means. If you'd like to change the **marginaleffects** default to use the mean, too, you can execute the following.

```{r}
options(marginaleffects_posterior_center = mean)
```

Now notice the change in the output.

```{r}
# predicted means
predictions(fit1, newdata = nd, by = "experimental")
# ATE
predictions(fit1, newdata = nd, by = "experimental", hypothesis = "revpairwise")
```

These results are now exactly the same as the ones we computed by hand with the `fitted()`-based code, above. If desired, you could change the settings back to the default by executing `options(marginaleffects_posterior_center = stats::median)`.

#### Compute $\mathbb E (y_i^1 - y_i^0)$ from `fit1`.

Before we compute the ATE with the $\mathbb E (y_i^1 - y_i^0)$ method, we'll first need to redefine our predictor grid `nd`.

```{r}
nd <- horan1971 %>% 
  select(sn) %>% 
  expand_grid(experimental = 0:1) %>% 
  mutate(row = 1:n())

# what?
glimpse(nd)
```

Notice that unlike what we've done before, we added a `row` index. This will help us join our `nd` data to the `fitted()` output, below. Speaking of which, here's the ATE.

```{r}
fitted(fit1,
       newdata = nd,
       summary = F) %>% 
  data.frame() %>% 
  set_names(pull(nd, row)) %>% 
  mutate(draw = 1:n()) %>% 
  pivot_longer(-draw) %>% 
  mutate(row = as.double(name)) %>% 
  left_join(nd, by = "row") %>% 
  select(-name, -row) %>% 
  pivot_wider(names_from = experimental, values_from = value) %>% 
  mutate(tau = `1` - `0`) %>% 
  # first compute the ATE within each MCMC draw
  group_by(draw) %>% 
  summarise(ate = mean(tau)) %>% 
  select(ate) %>% 
  # now summarize the ATE across the MCMC draws
  brms_summary()
```

Returning to the equation from a two sections up, the `group_by()` and `summarise()` lines were how we computed $\mathbb E_j (y_{ij}^1 - y_{ij}^0)$ for each of the $J$ MCMC draws. It was then in the final `brms_summary()` line where we summarized the vector of all those resulting $\tau_{\text{ATE}_j}$ results. We can make the same computation with the `marginaleffects::avg_comparisons()` function.

```{r}
avg_comparisons(fit1, variables = list(experimental = 0:1))
```

Not only are the results from the `fitted()`- and `avg_comparisons()`-based approaches identical, here, but they're also identical to the results from the previous section. 

### Counterfactual interventions, with covariates, with the Gauss.

#### Compute $\mathbb E (y_i^1 \mid \bar c) - \mathbb E (y_i^0 \mid \bar c)$ from `fit2`.

We need to redefine our `nd` predictor grid, which now includes the mean of `prec`.

```{r}
nd <- horan1971 %>% 
  summarise(prec = mean(prec)) %>% 
  expand_grid(experimental = 0:1)

# what?
print(nd)
```

The `fitted()`-based workflow is much the same as before.

```{r}
fitted(fit2,
       newdata = nd,
       summary = F) %>% 
  data.frame() %>% 
  set_names(pull(nd, experimental)) %>% 
  mutate(ate = `1` - `0`) %>% 
  brms_summary()
```

The `predictions()` version of the code remains simple, too.

```{r}
# predicted means
predictions(fit2, newdata = nd, by = "experimental")
# ATE
predictions(fit2, newdata = nd, by = "experimental", hypothesis = "revpairwise")
```

#### Compute $\mathbb E (y_i^1 - y_i^0 \mid c_i)$ from `fit2`.

Redefine the `nd` predictor grid, which once again includes a `row` index.

```{r}
nd <- horan1971 %>% 
  select(sn, prec) %>% 
  expand_grid(experimental = 0:1) %>% 
  mutate(row = 1:n())

# what?
glimpse(nd)
```

Now compute the ATE via the $\mathbb E (y_i^1 - y_i^0 \mid c_i)$ method based on the posterior draws from our Bayesian `fit2`.

```{r}
fitted(fit2,
       newdata = nd,
       summary = F) %>% 
  data.frame() %>% 
  set_names(pull(nd, row)) %>% 
  mutate(draw = 1:n()) %>% 
  pivot_longer(-draw) %>% 
  mutate(row = as.double(name)) %>% 
  left_join(nd, by = "row") %>% 
  select(-name, -row) %>% 
  pivot_wider(names_from = experimental, values_from = value) %>% 
  mutate(tau = `1` - `0`) %>% 
  # first compute the ATE within each MCMC draw
  group_by(draw) %>% 
  summarise(ate = mean(tau)) %>% 
  select(ate) %>% 
  # now summarize the ATE across the MCMC draws
  brms_summary()
```

Now confirm it works with the `avg_comparisons()` approach.

```{r}
avg_comparisons(fit2, variables = list(experimental = 0:1))
```

Note how these results are identical to the posterior summary for the $\beta_1$ parameter.

```{r, warning = F}
# retrieve the MCMC draws
as_draws_df(fit2) %>% 
  # subset to our 3 focal columns
  transmute(`beta[1]` = b_experimental) %>% 
  # summarize
  brms_summary()
```

## Logistic regression

For the second half of this post, let's revisit the @wilson2017internet data from the last post.

```{r}
wilson2017 <- readxl::read_excel("data/S1Data.xls", sheet = "data")

# subset
set.seed(1)

wilson2017 <- wilson2017 %>% 
  mutate(msm = ifelse(msm == 99, NA, msm)) %>% 
  drop_na(anytest, gender, partners, msm, ethnicgrp, age) %>% 
  slice_sample(n = 400) %>% 
  # factors
  mutate(gender    = factor(gender, levels = c("Female", "Male")),
         msm       = factor(msm, levels = c("other", "msm")),
         partners  = factor(partners, levels = c(1:9, "10+")),
         ethnicgrp = factor(ethnicgrp,
                            levels = c("White/ White British", "Asian/ Asian British", "Black/ Black British", "Mixed/ Multiple ethnicity", "Other"))) %>% 
  # z-score
  mutate(agez = (age - mean(age)) / sd(age)) %>% 
  # make a simple treatment dummy
  mutate(tx = ifelse(group == "SH:24", 1, 0)) %>% 
  rename(id = anon_id) %>% 
  select(id, tx, anytest, gender, partners, msm, ethnicgrp, age, agez)

# what?
glimpse(wilson2017)
```

### Binomial models.

Here's what are Binomial ANOVA-type model for the `anytest` variable might look like when including our Bayesian priors:

$$
\begin{align*}
\text{anytest}_i & \sim \operatorname{Binomial}(n = 1, p_i) \\
\operatorname{logit}(p_i) & = \beta_0 + \beta_1 \text{tx}_i \\
\beta_0 & \sim \operatorname{Normal}(0, 1.25) \\
\beta_1 & \sim \operatorname{Normal}(0, 1).
\end{align*}
$$

Since I'm not a medical researcher, I'm switching to a more generic weakly-regularizing approach to the priors for this model and the next. When you're using the logit link, the $\operatorname{Normal}(0, 1.25)$ prior will gently nudge the $\beta_0$ posterior toward the middle of the probability space, while allowing for estimates anywhere along the possible range. To give you a sense, here are 100,000 draws from $\operatorname{Normal}(0, 1.25)$, which are then converted back to the probability space with the inverse logit function.

```{r, fig.width = 4, fig.height = 2.75}
set.seed(4)
tibble(n = rnorm(1e5, 0, 1.25)) %>% 
  mutate(p = inv_logit_scaled(n)) %>% 
  ggplot(aes(p)) +
  geom_histogram(boundary = 0, binwidth = 0.025) +
  scale_x_continuous(labels = c("0", ".25", ".5", ".75", "1"), expand = c(0, 0)) +
  scale_y_continuous(NULL, breaks = NULL) +
  labs(title = expression(logit^{-1}*(italic(N)(0*", "*1.25))),
       x = expression(italic(p)(beta[0])*" on the probability scale"))
```

The $\operatorname{Normal}(0, 1)$ prior for the active treatment coefficient, $\beta_1$, is also a generic weakly-regularizing prior on the logit scale.

Now here's the formula for the Bayesian ANCOVA version of the model:

$$
\begin{align*}
\text{anytest}_i & \sim \operatorname{Binomial}(n = 1, p_i) \\
\operatorname{logit}(p_i) & = \beta_0 + \beta_1 \text{tx}_i \\
& \;\; + \beta_2 \text{agez}_i \\
& \;\; + \beta_3 \text{Male}_i \\
& \;\; + \beta_4 \text{MSM}_i \\
& \;\; + \beta_5 \text{Asian}_i + \beta_6 \text{Black}_i + \beta_7 \text{Mixed}_i + \beta_8 \text{Other}_i \\
& \;\; + \beta_9 \text{partners2}_i + \beta_{10} \text{partners3}_i + \dots + \beta_{17} \text{partners10}\texttt{+}_i \\
\beta_0 & \sim \operatorname{Normal}(0, 1.25) \\
\beta_1, \dots, \beta_{17} & \sim \operatorname{Normal}(0, 1).
\end{align*}
$$

Now we're extending the generic $\operatorname{Normal}(0, 1)$ prior to all predictor variables in the model. I have no doubt a real medical researcher could have set better priors. This is what you get when you let a psychologist put his mitts on your data.

Here's how to fit the Bayesian binomial models with the `brm()` function.

```{r, eval = F}
# Bayesian binomial ANOVA
fit3 <- brm(
  data = wilson2017,
  family = binomial,
  anytest | trials(1) ~ 0 + Intercept + tx,
  prior = prior(normal(0, 1.25), class = b, coef = Intercept) +
    prior(normal(0, 1), class = b, coef = tx),
  cores = 4, seed = 4
)

# Bayesian binomial ANCOVA
fit4 <- brm(
  data = wilson2017,
  family = binomial,
  anytest | trials(1) ~ 0 + Intercept + tx + agez + gender + msm + ethnicgrp + partners,
  prior = prior(normal(1, 1.25), class = b, coef = Intercept) +
    prior(normal(0, 1), class = b),
  cores = 4, seed = 4
)
```

The parameter summary for the binomial ANCOVA `fit3` is pretty similar to the results from the `glm()`-based version of the model. You'll note many of the parameters from our Bayesian `fit4` are more conservative compared to its frequentist counterpart. That's what happens when you use a regularizing prior.

```{r}
print(fit3)
print(fit4)
```

```{r, eval = F, echo = F}
pp_check(fit3, ndraws = 100, type = "bars") + coord_cartesian(ylim = c(0, 300))
pp_check(fit4, ndraws = 100, type = "bars") + coord_cartesian(ylim = c(0, 300))
```

### Counterfactual interventions, no covariates, with the binomial.

The overall format in the next few sections will follow the same sensibilities as those from above. We'll be practicing most of the primary estimates from the [third post](https://timely-flan-2986f4.netlify.app/blog/2023-02-13-causal-inference-with-logistic-regression/#ate-for-the-anova) in this series. The main new addition is we'll also consider work flows based around the handy `add_epred_draws()` function from the **tidybayes** package [@R-tidybayes]. Do note, the `add_epred_draws()` function would also have worked fine for the Gaussian models, above. I just waited until now because I didn't want to overwhelm you with code in the first half of the blog.

#### Compute $\Pr (y_i^1 = 1) - \Pr(y_i^0 = 1)$ from `fit3`.

When working with a `brm()` binomial model, the `fitted()` default is to return the posterior draws on the probability scale.

```{r}
nd <- tibble(tx = 0:1)

fitted(fit3,
       newdata = nd,
       summary = F) %>% 
  data.frame() %>% 
  set_names(pull(nd, tx)) %>% 
  mutate(ate = `1` - `0`) %>% 
  brms_summary()
```

We can get the equivalent results from this `add_epred_draws()`-based code.

```{r}
nd %>% 
  add_epred_draws(fit3) %>% 
  ungroup() %>%
  select(tx, .draw, .epred) %>% 
  pivot_wider(names_from = tx, values_from = .epred)  %>% 
  mutate(ate = `1` - `0`) %>% 
  brms_summary()
```

The `predictions()` function works much the same as before.

```{r}
# predicted probabilities
predictions(fit3, newdata = nd, by = "tx")
# ATE
predictions(fit3, newdata = nd, by = "tx", hypothesis = "revpairwise")
```

#### Compute $\mathbb E (p_i^1 - p_i^0)$ from `fit3`.

Note how once again, we include a `row` index for the `nd` data grid when using any variant of the $\mathbb E (y_i^1 - y_i^0)$ approach for computing the ATE.

```{r}
nd <- wilson2017 %>% 
  select(id) %>% 
  expand_grid(tx = 0:1) %>% 
  mutate(row = 1:n())

# what?
glimpse(nd)
```

Now compute the ATE with `fitted()`.

```{r}
fitted(fit3,
       newdata = nd,
       summary = F) %>% 
  data.frame() %>% 
  set_names(pull(nd, row)) %>% 
  mutate(draw = 1:n()) %>% 
  pivot_longer(-draw) %>% 
  mutate(row = as.double(name)) %>% 
  left_join(nd, by = "row") %>% 
  select(-name, -row) %>% 
  pivot_wider(names_from = tx, values_from = value) %>% 
  mutate(tau = `1` - `0`) %>% 
  # first compute the ATE within each MCMC draw
  group_by(draw) %>% 
  summarise(ate = mean(tau)) %>% 
  select(ate) %>% 
  # now summarize the ATE across the MCMC draws
  brms_summary()
```

Here's the `add_epred_draws()` alternative.

```{r}
nd %>% 
  add_epred_draws(fit3) %>% 
  ungroup() %>%
  select(tx, id, .draw, .epred) %>% 
  pivot_wider(names_from = tx, values_from = .epred) %>% 
  mutate(tau = `1` - `0`) %>% 
  # first compute the ATE within each MCMC draw
  group_by(.draw) %>% 
  summarise(ate = mean(tau)) %>% 
  select(ate) %>% 
  # now summarize the ATE across the MCMC draws
  brms_summary()
```

Here's the `avg_comparisons()` approach.

```{r}
avg_comparisons(fit3, variables = list(tx = 0:1))
```

Each time, the results are exactly the same.

### Counterfactual interventions, with covariates, with the binomial.

#### Compute $\operatorname{\mathbb{E}} \left (p_i^1 \mid \mathbf{\bar C}, \mathbf D^m \right) - \operatorname{\mathbb{E}} \left (p_i^0 \mid \mathbf{\bar C}, \mathbf D^m \right)$ from `fit4`.

As in the [last post](https://timely-flan-2986f4.netlify.app/blog/2023-02-13-causal-inference-with-logistic-regression/#compute-operatornamemathbbe-left-p_i1--mathbfbar-c-mathbf-dm-right---operatornamemathbbe-left-p_i0--mathbfbar-c-mathbf-dm-right-from-glm2), we going to want to make a custom function to compute the modes for a few variables.

```{r}
get_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}
```

Now we have `get_mode()`, let's define our predictor grid to contain the mean for `agez`, the only variable in our $\mathbf{C}$ vector, and the modes for the remaining discrete variables, all in the $\mathbf{D}$ vector.

```{r}
nd <- wilson2017 %>% 
  summarise(agez      = 0,  # recall agez is a z-score, with a mean of 0 by definition
            gender    = get_mode(gender),
            msm       = get_mode(msm),
            ethnicgrp = get_mode(ethnicgrp),
            partners  = get_mode(partners)) %>% 
  expand_grid(tx = 0:1)

# what is this?
print(nd)
```

We're ready to compute the treatment effect at the means/modes with `fitted()`.

```{r}
fitted(fit4,
       newdata = nd,
       summary = F) %>% 
  data.frame() %>% 
  set_names(pull(nd, tx)) %>% 
  mutate(ate = `1` - `0`) %>% 
  brms_summary()
```

Here's how to compute that $\tau_\text{TEMM}$ with `add_epred_draws()`.

```{r}
nd %>% 
  add_epred_draws(fit4) %>% 
  ungroup() %>%
  select(tx, .draw, .epred) %>% 
  pivot_wider(names_from = tx, values_from = .epred)  %>% 
  mutate(ate = `1` - `0`) %>% 
  brms_summary()
```

Here's $\tau_\text{TEMM}$ via `predictions()`.

```{r}
# conditional probabilities
predictions(fit4, newdata = nd, by = "tx")

# TEMM
predictions(fit4, newdata = nd, by = "tx", hypothesis = "revpairwise")
```

For the sake of brevity, I'm going to skip the other $\tau_\text{CATE}$ example from the [last post](https://timely-flan-2986f4.netlify.app/blog/2023-02-13-causal-inference-with-logistic-regression/#compute-operatornamemathbbe-p_i1--mathbf-c--mathbf-c-mathbf-d--mathbf-d---operatornamemathbbe-p_i0--mathbf-c--mathbf-c-mathbf-d--mathbf-d-from-glm2). The workflow is nearly the same. You just need to put different covariate vales into the `nd` predictor grid.

#### Compute $\mathbb E (p_i^1 - p_i^0 \mid \mathbf C_i, \mathbf D_i)$ from `fit4`.

Update the `nd` predictor grid, with the good old `row` index.

```{r}
nd <- wilson2017 %>% 
  select(id, age, agez, gender, msm, ethnicgrp, partners) %>% 
  expand_grid(tx = 0:1) %>% 
  mutate(row = 1:n())

# what?
glimpse(nd)
```

Use the $\mathbb E (p_i^1 - p_i^0 \mid \mathbf C_i, \mathbf D_i)$ method to compute the ATE with `fitted()`.

```{r}
fitted(fit4,
       newdata = nd,
       summary = F) %>% 
  data.frame() %>% 
  set_names(pull(nd, row)) %>% 
  mutate(draw = 1:n()) %>% 
  pivot_longer(-draw) %>% 
  mutate(row = as.double(name)) %>% 
  left_join(nd, by = "row") %>% 
  select(-name, -row) %>% 
  pivot_wider(names_from = tx, values_from = value) %>% 
  mutate(tau = `1` - `0`) %>% 
  # first compute the ATE within each MCMC draw
  group_by(draw) %>% 
  summarise(ate = mean(tau)) %>% 
  select(ate) %>% 
  # now summarize the ATE across the MCMC draws
  brms_summary()
```

Compute the same with the `add_epred_draws()` alternative.

```{r}
nd %>% 
  add_epred_draws(fit4) %>% 
  ungroup() %>%
  select(tx, id, .draw, .epred) %>% 
  pivot_wider(names_from = tx, values_from = .epred) %>% 
  mutate(tau = `1` - `0`) %>% 
  # first compute the ATE within each MCMC draw
  group_by(.draw) %>% 
  summarise(ate = mean(tau)) %>% 
  select(ate) %>% 
  # now summarize the ATE across the MCMC draws
  brms_summary()
```

Or just use `avg_comparisons()`.

```{r}
avg_comparisons(fit4, newdata = nd, variables = "tx")
```

In the [last post](https://timely-flan-2986f4.netlify.app/blog/2023-02-13-causal-inference-with-logistic-regression/#compute-mathbb-e-p_i1---p_i0--mathbf-c_i-mathbf-d_i-from-glm2), we showcased the diversity among the $\tau_i$'s with a coefficient plot. Here's how to make the analogous plot for the Bayesian version of the model, using a `fitted()`-based work flow.

```{r, fig.width = 8, fig.height = 5}
fitted(fit4,
       newdata = nd,
       summary = F) %>% 
  data.frame() %>% 
  set_names(pull(nd, row)) %>% 
  mutate(draw = 1:n()) %>% 
  pivot_longer(-draw) %>% 
  mutate(row = as.double(name)) %>% 
  left_join(nd, by = "row") %>% 
  select(-name, -row) %>% 
  pivot_wider(names_from = tx, values_from = value) %>% 
  mutate(tau = `1` - `0`) %>% 
  # compute the case specific means and 95% CIs
  group_by(id) %>% 
  mean_qi(tau) %>% 
  # sort the output by the point estimates
  arrange(tau) %>% 
  # make an index for the ranks
  mutate(rank = 1:n()) %>% 
  
  # plot!
  ggplot(aes(x = tau, xmin = .lower, xmax = .upper, y = rank)) +
  geom_pointrange(linewidth = 1/10, fatten = 1/10) +
  scale_y_continuous(NULL, breaks = NULL) +
  labs(title = "Behold the diversity among the individual treatment effect estimates.",
       x = expression(hat(tau)[italic(i)]~("i.e., "*hat(italic(p))[italic(i)]^1-hat(italic(p))[italic(i)]^0))) +
  coord_cartesian(xlim = c(-0.1, 0.4))
```

If you compare this plot with the original maximum-likelihood version from the [last post](https://timely-flan-2986f4.netlify.app/blog/2023-02-13-causal-inference-with-logistic-regression/#compute-mathbb-e-p_i1---p_i0--mathbf-c_i-mathbf-d_i-from-glm2), you'll note our priors have reigned some of the posteriors in a bit, particularly the $\tau_i$'s with the lowest rank. I don't know that one solution is more correct than the other, but priors do change the model.

Since we're plotting, we might also show the whole posterior distribution for the resulting $\tau_\text{ATE}$. Here we'll base our wrangling workflow on the `add_epred_draws()` method, and then plot the results with help from the `stat_halfeye()` function.

```{r, fig.width = 6, fig.height = 3}
nd %>% 
  add_epred_draws(fit4) %>% 
  ungroup() %>%
  select(tx, id, .draw, .epred) %>% 
  pivot_wider(names_from = tx, values_from = .epred) %>% 
  mutate(tau = `1` - `0`) %>% 
  group_by(.draw) %>% 
  summarise(ate = mean(tau)) %>% 
  
  ggplot(aes(x = ate)) +
  stat_halfeye(.width = c(.5, .95)) +
  scale_y_continuous(NULL, breaks = NULL) +
  labs(subtitle = "Why summarize like a sucker when you can show the whole posterior?",
       x = expression(tau[ATE]))
```

## Recap

In this post, some of the main points we covered were:

* At a basic level, causal inference with Bayesian GLM's isn't that different from when we're working as frequentists. The main difference is in the post-processing steps.
* We can compute identical results for the $\tau_\text{ATE}$ or $\tau_\text{CATE}$ with
  - a `fitted()`-based approach,
  - an `as_draws_df()`-based approach, or
  - a `predictions()`/`avg_comparisons()`-based approach.

In the next post, we'll explore how our causal inference methods work with a gamma regression model. Until then, happy modeling, friends!

## Session information

```{r}
sessionInfo()
```

## References

```{r, eval = F, echo = F}
wilson2017 %>% 
  select(id, age, agez, gender, msm, ethnicgrp, partners) %>% 
  expand_grid(tx = 0:1) %>% 
  mutate(row = 1:n()) %>% 
  
  add_epred_draws(fit4) %>% 
  ungroup() %>%
  select(tx, id, .draw, .epred) %>% 
  pivot_wider(names_from = tx, values_from = .epred) %>% 
  mutate(tau = `1` - `0`) %>% 
  group_by(.draw) %>% 
  summarise(ate = mean(tau)) %>% 
  
  ggplot(aes(x = ate)) +
  stat_halfeye(.width = .95, color = "#420D09", fill = "#e23a2d") +
  scale_y_continuous(NULL, breaks = NULL) +
  labs(subtitle = "Plot your posterior",
       x = expression(tau[ATE])) +
  theme(text = element_text(color = "#420D09"),
        axis.text = element_text(color = "#420D09"),
        axis.ticks = element_line(color = "#420D09"),
        panel.background = element_rect(fill = "#fceceb"),
        plot.background = element_rect(fill = "#fffcfc"))

# color palette following a suggestion from Stephen Wild
# https://twitter.com/stephenjwild/status/1622705919346835460
# https://www.colorhexa.com/420d09
ggsave("plot-tau-ate-featured.jpg", width = 3.6, height = 3.5, units = "in")
```

